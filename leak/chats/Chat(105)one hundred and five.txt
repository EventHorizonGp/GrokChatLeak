id: 105



look into this https://osv.dev/vulnerability/ASB-A-406785684 and find exactly the source code file, function and lines responsible. return the link to the source file, the snippet of code that's vulnerable and a brief explaination of why it is and how an attacker might leverage the vulnerability.
Key Points

    The vulnerability (ASB-A-406785684, CVE-2025-48539) is a use-after-free issue in the Bluetooth module, specifically in the SendPacketToPeer function of acl_arbiter.cc, which can lead to an out-of-bounds read and potentially remote code execution over Bluetooth.
    It affects Android versions 15, 16, and 16-next prior to the September 2025 security patch.
    The issue arises from accessing a buffer's length after a function call that may free the buffer on failure, creating a use-after-free scenario.

Source File Link

The source file is located in the Android Open Source Project (AOSP) repository at: https://android.googlesource.com/platform/packages/modules/Bluetooth/+/refs/heads/main/system/stack/arbiter/acl_arbiter.cc.
Vulnerable Code Snippet

The vulnerable code is within the SendPacketToPeer function (lines 101-105 in the file). Here's the relevant excerpt showing the problematic access:
text

if (stack::l2cap::get_interface().L2CA_SendFixedChnlData(L2CAP_ATT_CID, p_tcb->peer_bda,
                                                         p_buf) != tL2CAP_DW_RESULT::SUCCESS) {
  log::warn("Unable to send L2CAP data peer:{} fixed_cid:{} len:{}", p_tcb->peer_bda,
            L2CAP_ATT_CID, p_buf->len);
}

Brief Explanation

The vulnerability stems from a use-after-free error: the L2CA_SendFixedChnlData function may free the p_buf buffer if the data send operation fails, but the subsequent logging statement still accesses p_buf->len, resulting in an out-of-bounds read. An attacker could leverage this by establishing a proximal Bluetooth connection and crafting packets that force the send operation to fail in a controlled manner, potentially allowing memory corruption, information disclosure, or escalation to remote code execution without user interaction or additional privileges.
review.lineageos.org
osv.dev

The Android Security Bulletin vulnerability ASB-A-406785684, also tracked as CVE-2025-48539, represents a critical flaw in the Bluetooth subsystem of Android devices. This issue, classified as a use-after-free (UAF) leading to an out-of-bounds read, was disclosed in the September 2025 security updates and affects multiple Android versions. In this comprehensive overview, we delve into the technical details of the vulnerability, its root cause, the impacted components, potential exploitation paths, mitigation strategies, and broader implications for Android security. This analysis draws from official sources including the Open Source Vulnerabilities (OSV) database, AOSP commit history, and related security patches to provide a thorough understanding.
Background on the Bluetooth Stack in Android

Android's Bluetooth implementation, known as the Fluoride stack (part of the broader Bluetooth module), handles low-level communication protocols such as ACL (Asynchronous Connection-Less) links for data transfer. The file acl_arbiter.cc is part of the system/stack/arbiter directory within the platform/packages/modules/Bluetooth repository in AOSP. This component arbitrates ACL connections, managing packet transmission to peers over fixed channels like the ATT (Attribute Protocol) CID used in Bluetooth Low Energy (BLE) interactions.

The SendPacketToPeer function is responsible for preparing and dispatching packets to a connected Bluetooth peer. It involves allocating a buffer (BT_HDR), copying data into it, and attempting to send it via the L2CAP (Logical Link Control and Adaptation Protocol) layer. Failures in this process can occur due to various reasons, such as connection issues, buffer overflows, or malformed inputs from the peer.
Vulnerability Details

The core issue is a classic use-after-free vulnerability in the SendPacketToPeer function of acl_arbiter.cc. Specifically:

    A buffer p_buf is allocated using osi_malloc and populated with data from a Rust vector (::rust::Vec<uint8_t>).
    The buffer is passed to L2CA_SendFixedChnlData, which attempts to send the data over the L2CAP ATT channel.
    If the send fails (return value not tL2CAP_DW_RESULT::SUCCESS), a warning is logged, including the buffer's length (p_buf->len).

However, under certain failure conditions, L2CA_SendFixedChnlData may deallocate the p_buf buffer internally. Accessing p_buf->len after this point constitutes a use-after-free, which can corrupt memory or trigger an out-of-bounds read. This behavior was confirmed through analysis of the vulnerability description and related patches.
osv.dev
review.lineageos.org

The full function context (from lines 87-109 in the source file) is as follows for reference:
text

void AclArbiter::SendPacketToPeer(uint8_t tcb_idx, ::rust::Vec<uint8_t> buffer) {
#ifdef TARGET_FLOSS
  return;
#endif
  tGATT_TCB* p_tcb = gatt_get_tcb_by_idx(tcb_idx);
  if (p_tcb != nullptr) {
    BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(BT_HDR) + buffer.size() + L2CAP_MIN_OFFSET);
    if (p_buf == nullptr) {
      log::fatal("OOM when sending packet");
    }
    auto p = (uint8_t*)(p_buf + 1) + L2CAP_MIN_OFFSET;
    std::copy(buffer.begin(), buffer.end(), p);
    p_buf->offset = L2CAP_MIN_OFFSET;
    p_buf->len = buffer.size();
    if (stack::l2cap::get_interface().L2CA_SendFixedChnlData(L2CAP_ATT_CID, p_tcb->peer_bda,
                                                             p_buf) != tL2CAP_DW_RESULT::SUCCESS) {
      log::warn("Unable to send L2CAP data peer:{} fixed_cid:{} len:{}", p_tcb->peer_bda,
                L2CAP_ATT_CID, p_buf->len);
    }
  } else {
    log::error("Dropping packet since connection no longer exists");
  }
}

The problematic lines are 101-105, where the send failure branch accesses the potentially freed buffer.
Affected Versions and Severity

This vulnerability impacts Android devices running unpatched versions of the Bluetooth module. According to the OSV entry, it affects:
Android Version	Introduced	Fixed	Severity	Type
15	15:0	15:2025-09-01	Critical	RCE
16	16:0	16:2025-09-01	Critical	RCE
16-next	16-next:0	16-next:2025-09-01	Critical	RCE

    Severity: Critical, as it enables remote code execution (RCE) without user interaction.storage.googleapis.com
    Exploit Requirements: Proximal/adjacent access (e.g., within Bluetooth range, typically 10-30 meters), no additional privileges, and no user interaction needed.
    Patches: Google provided fixes via commits in AOSP:
        Android 15: 59d787dcbf5a95d0f00f28970dc98906f3c53832
        Android 16: d6cb1ec8d11d2a8239c9f7e824f6fbe29edeb2e6
        Android 16-next: 243d7484e59730c522640b616445b2747b3062e5.
        osv.dev
        storage.googleapis.com

Custom ROMs like LineageOS have backported the fix, as seen in their Gerrit changes.review.lineageos.org
Exploitation Analysis

Exploiting this vulnerability requires an attacker to be in Bluetooth range and capable of influencing the send operation to fail predictably. Potential steps include:

    Establish Connection: Initiate an ACL connection to the target device, possibly masquerading as a legitimate peripheral.
    Trigger Failure: Send malformed or timed packets that cause L2CA_SendFixedChnlData to fail and free p_buf (e.g., by overflowing queues or violating protocol constraints).
    Memory Corruption: The UAF allows reading from freed memory, potentially disclosing sensitive data (out-of-bounds read). If the attacker can allocate objects in the freed slot (heap spraying via Bluetooth packets), this could escalate to arbitrary code execution within the Bluetooth process context.
    Chaining: Combine with other flaws for privilege escalation, though the base exploit grants RCE at the app level without extra privileges.

While no public exploits exist as of September 2025, the proximal nature limits mass attacks but poses risks in crowded environments (e.g., public transport). Defenses include disabling Bluetooth when unused and applying patches promptly.
Mitigation and Fixes

The official fix likely involves capturing the buffer length before the send call to avoid post-failure access:

    Vulnerable: Access p_buf->len after potential free.
    Fixed: uint16_t len = p_buf->len; before the if-statement, then use len in the log.

Users should update to the September 2025 security patch level (SPL: 2025-09-01). Developers working with AOSP can apply the referenced commits. Additionally, vanir signatures in the OSV JSON enable detection in binaries via line hashes for auditing.storage.googleapis.com
Broader Implications

This flaw highlights ongoing challenges in C++ memory management within Android's native components, where manual allocation (e.g., osi_malloc) increases UAF risks. Transitioning to safer constructs like smart pointers or Rust (noted in the code via ::rust::Vec) could mitigate similar issues. It also underscores the importance of timely patches in the fragmented Android ecosystem, where delayed OEM updates leave devices exposed.

In summary, ASB-A-406785684 serves as a reminder of the security trade-offs in wireless protocols, emphasizing rigorous code reviews and fuzzing for network-facing code.

Key Citations:

    ASB-A-406785684 - OSV.devosv.dev
    ASB-A-406785684 JSON Datastorage.googleapis.com
    acl_arbiter.cc Source Code
    Fix use after free in acl_arbiter (449950) - Gerrit Code Reviewreview.lineageos.org
    Fix use after free in acl_arbiter - LineageOS Reviewreview.lineageos.org

Web page favicon
Web page favicon
Web page favicon
25 web pages
